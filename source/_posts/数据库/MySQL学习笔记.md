---
title: MySQL学习笔记
permalink: MySQL学习笔记
sticky: true
cover: https://blog-1259743669.cos.ap-chengdu.myqcloud.com/image-20230905225131183.png
date: 2023-09-04 22:46:36
description: 这是显示在首页的概述，正文内容均会被隐藏。
tags: 
categories:
  - - 数据库
---

# 一、 Mysql基础篇

#### 语句执行流程

##### mysql查询语句执行流程：

1.  建立连接：这里需要验证身份和权限
2.  查询缓存(如果有缓存则直接返回缓存数据，如果木有则进行下一步，需要注意，如果有增删改操作会清除掉缓存)
3.  解析器:先做词法分析、再做语法分析 (注:表不存在或者字段不存在，并不是在解析器)
4.  执行器： 执行器有三个阶段，预处理阶段、优化阶段、执行阶段
5.  返回数据

- 词法分析主要是识别关键字构成语法树，这样方便后面的模块得到关键字、表名
  
- 语法分析主要是分析语法是否正确
  
- 预处理阶段：检查表名、列名是否存在 将*号换成所有列
  
- 优化阶段：优化器主要是将sql语句的执行计划确定下来，例如索引的选择、
  
- 执行阶段：执行器就会和存储引擎交互了，交互是以记录为单位的。
    ![image-20230905225131183](https://blog-1259743669.cos.ap-chengdu.myqcloud.com/image-20230905225131183.png)
    mysql更新语句执行流程：
    更新语句同样需要走一次查询数据的流程，但数据的更新是在存储引擎中做的，在本文中存储引擎选择的是Innodb。更新流程需要有日志的辅助，
    
- 重做日志: redo Log是物理日志，记录了某个数据页做了什么修改，每当执行一个事务就会产生一条或者多条物理日志。==事务提交时==，先将redo log持久化到磁盘即可。并且redo是可重用的，也就是说空间大小是可设置的，从头开始写，写到末尾又回到开头写， redo log解决了事务中的持久性. 这里到了一个 WAL技术，
    ==WAL技术指的是，MySQL的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。==
    
- 回滚日志: undo log是Innodb存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC。
    ==每开始一个事务都会分配一个 undo空间，在事务没提交之前Innodb会先记录更新前的数据到undo log中==，当需要执行回滚时 就执行一条相反的操作。undo log 有两个参数：roll\_pointer 指针和一个 trx\_id 事务id，通过 trx\_id 可以知道该记录是被哪个事务修改的；通过 roll\_pointer 指针可以将这些 undo log 串成一个链表，形成版本链。
    ==当事务提交后 相关的undo日志记录会被标记为"已提交"，这些已提交的undo日志记录会在后续的清理过程中被回收和删除==
    ==实现事务回滚，保障事务的原子性：如果出现了错误或者用户执行了 ROLLBACK 语句，可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。==
    
- 归档日志 ：Server 层生成的日志，主要用于数据备份和主从复制。binlog是server层的日志，不同的存储引擎都可用， 而上面两个是innoDB独有的，在完成一条更新操作后，Server 层会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写入 binlog 文件。binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作。
    1.执行器负责具体执行，会调用存储引擎的接口，通过索引获取到要操作的数据的记录
    

2.  执行器得到聚簇索引记录后 会查看更新前和更新后的数据是否一致，如果一致就不执行。
3.  开启事务，innodb在执行操作前需要先开启事务，InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来
4.  innodb层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了
5.  至此一条记录更新完成了
6.  在一条更新语句执行完成后，然后开始记录该语句对应的 binlog
7.  事务提交，事务提交分为两个阶段
    - prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；
    - commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；
        8.至此，一条更新语句执行完成。

# 二、日志篇

mysql日志文件分为三种:

### undo log 回滚日志

回滚日志是Innodb存储引擎层生成的日志，实现了事务中的原子性，主要是用于事务回滚和MVCC,考虑一个问题，一个事务在执行过程中还没有提交事务，mysql发生了崩溃，就需要undo log来回滚到事务之前的数据去。
undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。
![image-20230905225157734](https://blog-1259743669.cos.ap-chengdu.myqcloud.com/image-20230905225157734.png)
原理：
每当innodb引擎对一条记录进行操作时，要把回滚时需要的信息都记录到undolog里，发生回滚时就读取undolog的数据，做相反操作。不同的操作，记录的内容也不一样
另外undolog +readview 实现了MVCC：

1.  对于读提交隔离级别是在每个select都会生成一个新的read view 也意味着事务期间多次读取同一个数据 前后两次读的数据可能会出现不一致，因为另外一个事务修改了记录并提交了
2.  对于可重复读级别，是启动事务时生成了一个read view 然后整个事务期间都在用整个read view 这样就保证了事务期间读到的数据都是事务启动前的记录。
    ==undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。==

### redo log 重做日志

为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候innodb引擎会先更新内存，然后将本次对整个页的修改以redolog的形式记录下来，就算更新完成了，后续innodb会在适当的时候由后台线程将缓存在BufferPool的脏页刷新到磁盘，这就是WAL技术，WAL技术是指MYSQL的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写入到磁盘

1.  redolog有自己的内存缓存，
2.  redolog 有刷盘机制可手动配置
3.  InnoDB 存储引擎有 1 个重做日志文件组( redo log Group） 是一个文件组写完了可以循环写，防止丢失

#### undo和 redo的区别

这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：
redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值；
undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；
==事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，==

### binglog 归档日志

binglog主要是做备份和主从复制的，并且binglog是server层的日志，是全量日志，
而前面俩都是Innodb的日志，换一个存储引擎就没有了。binlog是追加写，一个文件写满了就创建一个新的继续写，不会覆盖日志，但是redolog会覆盖，
binglog日志有三种格式

1.  StateNet:每一条修改数据的sql都会被记录到binlog中，，主从复制时，可以直接运行语句复现，STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；
2.  row：记录行数据最终被修改的样子，
    4.mixed 包含了statement和row模式，会根据不同情况自动使用上面的两种日志

# 三、MySQL事务

插入一条数据发生了什么？
使用Innodb引擎时执行增删改操作时，会自动在Innodb引擎层开启事务。
ACID

- 原子性: 事务最小工作单元，要么全成功，要么全失败（重做日志了实现的）
- 一致性：事务开始和结束后，数据库的完整性不会被破坏
- 隔离性：不同事务之间互不影响，（是通过MVCC来实现的）
    1.  读未提交RU：一个事务读取到另一个事务未提交的数据。（会出现脏读）
    2.  读已提交（RC)：一个事务读取到另一个事务已经提交的数据，（会出现不可重复读，同一个sql语句在一个事务里面读到的数据不一致）
    3.  可重复读(RR)：一个事务只能读到另一个已经提交的事务修改的数据（会出现幻读，一个事务因读取到另一个事务已提交的insert数据或者dlete数据，导致对同一张表读取两次以上的结果不一致。查询结果是多条记录时，才有可能出现幻读。）
    4.  串行化：
- 持久性：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失。（回滚日志来实现的）

### 并行事务会引发什么问题

- 脏读：一个事务读到了另一个未提交事务修改过的数据
- 不可重复读：一个事务内两次读取数据出现不一致的情况，
- 幻读：在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一致，就是幻读。

### 事务与MVCC底层原理详解

MVCC实现了两个事务隔离级别，可重复读和读已提交，MVCC使数据库读不加锁，提高了数据库的并发处理能力，多版本并发控制仅仅是一种技术理念，没有统一的标准，其核心理念就是快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。
![image-20230905225220682](https://blog-1259743669.cos.ap-chengdu.myqcloud.com/image-20230905225220682.png)

- m_ids ：指的是在创建 Read View 时，当前数据库中活跃事务的事务 id 列表，活跃事务指的就是，启动了但还没提交的事务。
  
- min\_trx\_id ：指的是在创建 Read View 时，当前数据库中活跃事务中事务 id 最小的事务，也就是 m_ids 的最小值。
  
- max\_trx\_id ：创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1。
  
- creator\_trx\_id ：指的是创建该 Read View 的事务的事务 id。
  
- 如果记录的 trx\_id 值小于 Read View 中的 min\_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。
  
- 如果记录的 trx\_id 值大于等于 Read View 中的 max\_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。
  
- 如果记录的 trx\_id 值在 Read View 的min\_trx\_id和max\_trx\_id之间，需要判断 trx\_id 是否在 m_ids 列表中：
  
    - 如果记录的 trx\_id 在 m\_ids 列表中，表示生成该版本记录的活跃事务依然活跃着(还没提交事务)，所以该版本的记录对当前事务不可见。
    - 如果记录的 trx\_id 不在 m\_ids 列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。

### 如何解决幻读

分为快照读和当前读

#### 快照读

通过MVCC方式解决幻读，可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一直的。即使中途有其他事务写入了一条数据，也是查不出来的。
==对于快照读， MVCC 并不能完全避免幻读现象==。==当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读==

#### 当前读

通过next-key lock 方式解决了幻读，因为当执行select for update 语句的时候会加上 next key lock 如果有其他事务在锁范围内插入了已经语句 这个插入语句就会被阻塞.

#### LBCC 基于锁的并发控制。

一个事务去读一个数据库的时候就加上锁，不允许其他事务操作

#### Innodb的MVCC实现

MVCC在mysql中的实现是依赖的undo log和read view
MVCC只支持两种隔离级别 分别是：读已提交，可重复读
根据不同的行为，undo log分为两种 insert undo log和 update undo log
insert undo log是在inser操作下产生的undo log
因为insert操作的记录只对事务本身可见，对于其他事务

#### 读提交的实现

读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务

# 四、Mysq锁篇

### 锁介绍

范围分：全局锁，表级锁，行级锁
根据功能分: 共享锁（s)，排他锁(x)，
全局锁就是对整个数据库实例枷锁，加锁后整个数据库就处于只读状态，后续的MDL ，DDL语句 和已经更新操作的提交语句都将被阻塞，一般应用于数据库全局备份时，保证数据完整性和一致性。
加锁命令：flush table with read lock;
释放锁 unlock tables;
一般是在数据库做备份的时候才使用全局锁，但是会带来问题，全局锁会导致数据库在时间内处于只读状态，会导致业务停滞，
解决方案，如果数据库引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前可先开启事务，会先创建ReadView 然后整个事务执行期间都在使用这个ReadView ，而且在可重复读的情况下，即使其他业务更新数据库，也不会有影响。

* * *

表级锁(server实现的): 有四种 读锁，写锁，元数据锁

1.  表级共享锁：lock table 表名 read;
2.  表级排他锁: lock table 表名 write
3.  元数据锁： 在一个事务中对一个表进行查询操作不允许其他会话对表结构进行修改，就在表上加元数据锁
4.  自增锁：使用自增字段时，使用自增主键保证主键不冲突
5.  意向锁: 当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。
    那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录
    意向锁的目的是为了快速判断表里释放有记录被加锁

* * *

行级锁
**要求必须使用Innodb引擎**

- 记录锁：锁定索引中的一条记录
- 间隙锁: 要么锁住索引记录中间的值，要么锁住第一个索引记录前面的值或者最后一个索引记录后面的值
- 临健锁：是索引记录上的记录锁和在索引记录之前的间隙锁的组合（间隙锁+记录锁）
- 插入意向锁： 做insert操作时添加的对记录id的锁
    记录锁：根据主键等值更新时使用记录锁
    共享记录锁: select * from where id=1 lock inshare mode
    排他记录锁: select * from where id=1 for update;
    意向锁就是一个标志位，表示当前表中，是否有行锁
    意向锁分为：行锁：S意向锁：IS; 行锁X 意向锁:IX
    间隙锁：仅仅锁住一个索引区间，在记录和记录之间的范围区间就是间隙，间隙锁就是加在区间之上，防止插入数据，目的就是幻读(读一个范围数据，读到了其他数据插入的数据) 在更新过程中，不仅需要对记录加锁还需要在记录与记录之间加锁，加的就是间隙锁。
    临键锁 :就是记录锁+间隙锁，是一个左开右闭区间



### 死锁的产生

有两个会话，互相持有对方所需要的资源。

#### 如何避免死锁·

1、注意程序逻辑，最常见的就是更新表，程序的更新过程最好意思一致的
2、保持事务的轻量，越是轻量的事务，占有越少的锁资源，这样发生死锁的概率就很低了
3、提高运行速度，避免使用子查询，尽量使用主键等
4、尽快提交事务，减少持有锁的时间，事务越早提交，锁就越早释放。

# 五、索引

什么是索引，帮助快速查找数据的一个数据结构。索引可以说是数据的目录，
![image-20230905225256269](https://blog-1259743669.cos.ap-chengdu.myqcloud.com/image-20230905225256269.png)
索引分类
按数据结构来分，可以分为，B+树索引，Hash索引，Full-text索引
按物理存储分类：聚簇索引(主键索引)，二级索引(辅助索引)
按字段特性分类： 主键索引、唯一索引、普通索引、前缀索引
按字段个数分类： 单列索引，联合索引。
如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

#### 什么时候需要索引：

字段有唯一性限制的
经常用于where查询条件的字段，
经常用于group by 和order by的字段，这样查询的时候就不需要再去做一次排序了，

#### 什么时候不需要创建索引

字段中有大量重复数据的，比如性别
表数据很少的时候
经常更新的字段不需要索引，比如余额

#### 优化索引的方法

1.  **前缀索引优化**
    就是使用某个字段中字符串的前几个字符建立索引，使用前缀索引可以减少索引字段的大小，但是order by无法使用前缀索引，无法把前缀索引当做覆盖索引使用
    
2.  **覆盖索引优化**
    在索引B+树的叶子节点上都能找到的那些索引。可以建立联合索引，商品id 姓名，作为一个联合索引，可以避免回表。
    
3.  **主键索引最好自增**
    那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据
    
4.  **索引最后设置为NOT NULL**
    如果索引列存在NULL 会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。
    NULL 值是一个没意义的值，但是它会占用物理空间
    
5.  **防止索引失效**
    1.当使用左或者左右模糊匹配的时候，也就是like %xx或者like %xx% 这两种方法都会造成索引失效。
    
6.  当我们在查询条件中对索引列做了计算、函数、类型转换后也会导致失效。
    
7.  联合索引要遵循最左匹配原则不然也会失效。
    
8.  where 子句中，如果or前的条件列是索引，而or后的条件不是所有，那么也会导致索引失效。
    

All（全表扫描）
index（全索引扫描）
range（索引范围扫描）
ref（非唯一索引扫描）
eq_ref（唯一索引扫描）
const（结果只有一条的主键或唯一索引扫描）

#### count() 是什么？

count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。

### 索引的数据结构

Mysql的索引数据结构选用的是B+树，为什么选用呢？
索引至少要支持等值查询和范围查询。

#### 选择Hash表做查询

如果是等值查询，hash的性能是很好的，但是无法做范围查询，空间复杂度较高。

#### 二叉查找树

这个是可以做等着查询和范围查询的，但是极端情况下，可能会退化成链表。

#### 平衡二叉查找树

查找的时间复杂度和树的高度有关，树有多高就需要查找多少次，每个节点的读取都对应着一次IO操作，在表数据量变大时，树的高度也会变大，查询效率下降严重
并且平衡二叉查找树，不支持范围快速查找，范围查询时，需要通过根结点多次遍历。查询效率不高

#### B树

改造了二叉树，在一个节点上存多个数值，可以将树的高度变矮，降低磁盘的读取IO;
B树是一种多叉平衡查找树

B树：非叶子节点和叶子节点都会存储数据。
b树缺点：

1.  B树不支持范围查询的快速查找，如果我们想要查找15和26之间的数据，查找到15之后，需要回到
    根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
2.  如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的
    数据量就会变少，树相应就会变高，磁盘IO次数就会变大

#### B+树

而B+树只在叶子节点上存储数据，且使用链表将叶子节点连接起来。

#### 为什么用B+树不用B树

B+树相对于B树在磁盘IO操作上具有优势，尤其适用于范围查询和索引场景

在进行查询操作时，B树可能需要在内部节点上进行多次访问才能达到叶子节点，而B+树由于只有叶子节点存储数据，所以查询时只需一次访问。

### mysql索引实现

#### MyIsam引擎

主键索引实现是使用了B+树，MyISAM在查询时，会将索引节点缓存在MySQL缓存中，而数据缓存依赖于操作系统自身的缓存。

#### Innodbt引擎

索引和数据文件是放在一起的，Innodb引擎要求每张表必须有主键索引，
每个InnoDB表都有一个聚簇索引 ，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录。一般
情况下聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字
段来构建聚簇索引。

在使用辅助索引时，数据会回表，除聚簇索引之外的所有索引都称为辅助索引，InnoDB的辅助索引只会存储主键值而非磁盘地址，
使用辅助索引需要检索两遍索引：首先检索辅助索引获得主键，然后使用主键到主索引中检索获得记
录。根据在辅助索引树中获取的主键id，到主键索引树检索数据的过程称为回表查询。回表会有性能损耗，所以也有说在Innodb引擎里使用辅助索引，性能不如MyIsam引擎，因为在Mysaml里面辅助索引和主索引是相同的。

##### Innodb组合索引

组合索引就是一个字段包含多个索引。
如何存储的呢，是根据创建索引时的字段先后顺序，假设组合索引是 (a,b,c) ,那么在建立索引存储结构B+树时，就先按照a字段排序，当a字段相同时 ，就按b字段排序，当b字段相同时，就按c字段排序，在写sql语句的时候，要按照索引创建的顺序去写条件

##### 最左前缀匹配原则

#### 什么情况下适合建立索引

1.  频繁出现在 where条件 order排序 group分组 字段中的列
2.  select频繁查询的列，考虑是否创建联合索引
3.  多表join关联查询 ，on两边的字段都应该创建索引

#### 索引优化

1.  表记录很少不需创建索引 （索引是要有存储的开销）
2.  频繁更新的字段不适合创建索引
3.  区分度低的字段不适合建立索引，例如性别，会导致扫描行数过多，再加上回表查询的消耗。如果使用索引，比全表扫描的性能还要差。这些字段一般会用在组合索引中。
4.  在InnoDB存储引擎中，主键索引建议使用自增的长整型，避免使用很长的字段。
5.  不建议用无序的值作为索引。例如身份证、UUID，更新数据时会发生频繁的页分裂，页内数据不紧凑，浪费磁盘空间。
6.  尽量创建组合索引，而不是单列索引，一个组合索引等于多个单列索引
    创建原则：组合索引应该把把频繁的列，区分度高的值放在前面。频繁使用代表索引的利用率高，
    区分度高代表筛选粒度大，可以尽量缩小筛选范围

# 六、架构篇

#### mysql文件类型：

日志文件：
错误日志
通用日志：默认是关闭的，可以手动开启，，通用查询日志会记录用户所有的操作，
binlog:二进制日志，做Mysql主从复制时使用
慢查询日志: mysql调优时使用，默认关闭，
数据文件：
记录表结构、数据、索引信息
InnoDB ，MyIsam等
不同的存储引擎，生成的文件也不一样
在文件管理系统中 mysql的 一个数据库对应一个目录，
frm文件类型：表结构定义文件
MYD文件 Mylasm引擎创建的表，存储表中数据
MYI:文件 Mylasm引擎创建的表，存储表中索引
ibd文件 InnoDB引擎创建的表，其中包含表中数据和索引
MyIsam引擎创建的表有三个文件
InnoDB引擎创建的表有两个文件
同一个数据库中，不同的表可以使用不同的数据引擎，Mysql5.5开始默认使用InnoDB之前是使用的mylsam，

#### MYSQL架构：

```
大致分为两层:
mysqlServer层: 连接池、优化器、执行器等组件
存储引擎层： Innodb，以及其他引擎，基本可以忽略 
```

!\[\](…/…/B69V2_(NQHU5$@Q\[S18C9S9%201.png)
Mysql8中缓存被移除了，在mysql5.7中依然存在，默认是关闭的，
缓存的缺点：
1、需要占用大量的内存空间
2、维护缓存需要成本。
3、命中率不高
在同一个sql语句会反复执行时，可以开启，可以使用命令查看缓存命中率

分析器：
先对sql进行词法分析，语法分析
优化器：
执行器：

存储引擎
Mysql有多个自带存储引擎，也可以自己去安装第三方的存储引擎，
使用 show engines查看mysql中自带的存储引擎
**除非需要用到某些Innodb不具备的特性，并且没有其他办法可以替代，否则都应该选择Innodb引擎**
MEMORY ：内存引擎。把数据和索引全部放到内存中。缺点是，数据库一旦重启，表数据就丢失了，表结构不会丢失；优点速度快，

Innode引擎：
由，内存池，后台线程，磁盘文件三大部分组成，
内存结构:
redo log buffer（重做日志缓冲区)保证Mysql数据库完整性的重要组成部分
buffer poll 缓冲池
数据页缓存
索引页缓存
change buffer修改缓冲区（插入缓冲区），修改数据之后需要更新辅助索引，为了提高性能暂时先不更新，把要更新的操作放到缓冲区（change buffer）中。
自适应哈希索引：完全由mysql管理，无法人工干预，
磁盘结构：
1·系统表空间：ibdata1
数据字典
双写缓冲区
修改缓冲区，内存中的changebuffer的映射
回滚段，undolog
2、用户表空间（每个表一个）
默认情况下，每个表都对应一个ibd文件，就是用户表空间，用户的数据和索引都保存在用户表空间中
3、通用表空间
默认没有这个文件的，在mysql中，使用create tablespace命令创建的表空间就通用表空间。
4、回滚表空间
默认是没有的，undo tablespace默认是在系统表空间中，
5、临时表空间，
默认也是没有的，当使用临时表时才出现。
6、redolog 重做日志文件
就是mysql数据库数据完整性的重要保障文件。
由一组文件组成：
ib logfile0
iblogfile1
两个文件循环使用，文件不会增长。

## 二、Innodb架构组织

### Innodb磁盘文件结构

InnoDB的主要的磁盘文件主要分为三大块:一是系统表空间，二是用户表空间，三是redo日志文件和归档文件
三个表空间的区别，redo是日志：保证mysql数据不丢失的重要环节，采用WAL顺序写实现，系统表空间和用户表空间采用的就是随机写，

1.  redolog文件:
    由一组文件组成，默认是两个文件:ib\_logfile0和ib\_logfile1,循环写入，文件1写满之后写文件2，文件2写满之后写文件1，会覆盖之前的内容。
2.  系统表空间：
    文件中ibdata1,这就是系统表空间文件，其中包含
    1\. 数据字典
    2\. 双写缓冲区
    3\. 修改缓冲区
    4.回滚日志
3.  用户表空间：
    默认每个表对应一个表空间文件。*.ibd文件，是可配置的，由innodb\_file\_per_table 参数控制默认是true. 其中包含表中的数据和索引信息。
    用户表空间结构：
    ibd表空间文件
    分段： 段下面分成若干个区，每个区分成若干页（默认16k）（数据读写以页为单位，页里面存储的数据行，行大小取决于表结构），数据页的大小可以通过参数innode\_page\_size来进行调整；

而通用表空间和临时表空间用的不多。

![image-20230905225348775](https://blog-1259743669.cos.ap-chengdu.myqcloud.com/image-20230905225348775.png)

#### 1、Innodb的内存结构

1、redolog buffer ：为了减少磁盘的io，尽量将redolog相关的内容先写到缓冲区中，然后在合适的时机，将缓冲区的数据写到磁盘，合适的时机，就是 commit操作，在commit之前，先把redologBuffer中的数据写入到redolog文件，如果写入成功那么commit成功，如果写入失败则commit失败。
\[innodb\_flush\_log\_at\_trx_commit \]参数 是commiit操作时写redolog的行为 ，默认值配置的是1；

1.  属性值 为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入，每秒写入一次，
2.  当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲区的数据真正写入磁盘存储，确保不会出现数据丢失；（fsync是操作系统的函数）
3.  当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用文件系统的fsync ,而是让文件系统直接去判断何时将缓存写入磁盘。

#### 2、Buffer poll 缓存池

包含内容，数据页(16k)，索引页，自适应hash索引，双写缓冲区，修改缓冲区（插入缓冲区）

1.  数据页：当对数据进行修改时，先把对应的数据页（16k)放到内存中，然后再进行修改操作，此时内存数据页和磁盘数据页不一致，此时内存的数据页和磁盘的数据页不一致，内存的数据页就形成了脏页，一旦事务提交，就会记录到redolog，记录了对数据的修改，保证数据安全。当查询数据时，以内存数据为准。
2.  索引页：一旦向表中插入数据或者修改数据时，把索引页放到内存中，在内存中进行修改，数据安全同样是由redolog保证的。
3.  自适应hash索引：Innodb会根据分为频率和模式，为热点页建立哈希索引，来提高查询效率。不用我们自己维护。
4.  双写缓冲区：内存数据落盘时，需要使用双写缓冲区。
5.  修改缓冲区：也叫插入缓冲区，主要是对辅助索引修改时做的一个缓冲，辅助索引就是非主键索引。在早期版本中主要是针对插入操作。在新版本中，修改和删除页进行了缓冲

#### 3、内存数据落盘（重要）

当要做增删改操作时，会对Buffer pool操作时， 先写rdo log到缓冲，然后进行落盘操作，
checkPoint触发时机:
假设如果重做日志可以无限增大，同时缓冲池页足够大，那么是不需要将缓冲池页的新版本刷回磁盘，因为当发生宕机时，完全可以通过重做日志来恢复整个数据库系统中的数据到宕机发生时刻。需要两个前提， 缓冲池中可以缓存数据库中的所有数据，重做日志可以无限增大。

因此就有了checkPoint，主要解决了1、缩短数据库恢复时间，2、缓冲池不够用时，将脏页刷新到磁盘，3.重做日志不可用时刷新脏页
checkPonint分类：可分为 sharp checkPonint(强制)和 fuzzy checkPonint(模糊) ：
sharp checkPoint ：仅在关闭数据库的时候，将BufferPool中的脏页全部刷新到磁盘中，
fuzzy checkPoint : 数据库正常运行时，在不同的时机，将部分脏页写入磁盘，仅刷新部分脏页到磁盘。避免一次性刷新全部脏页造成性能问题。
有四个时机：
1、Master Thread CheckPoint :主线程定时将脏页写入磁盘，每秒将脏页写入，定时落盘
2、FLUSH\_LRU\_LIST CheckPoint 当buffer pool中脏页需要被淘汰时触发checkpoint。
3、Async/sync Flush CheckPoint ;异步或者同步落盘操作。跟redolog相关的，
4、Dirty Page too much CheckPoint ：buffer pool 中脏页过多时落盘，这个指标可配置

#### 4、脏页落盘过程

双写机制：
1、先把脏页写到 double write buffer(内存双写缓冲区)
2、把double write buffer的数据先写到系统表空间，
3、把缓冲区的数据写入用户表空间中；
4、如果写入系统表空间发生意外导致失败，可以使用用户表空间的数据页+redolog恢复数据。
5、如果系统表空间写入成功，用户表空间写入失败，可以使用系统表空间备份的数据页来恢复用户表空间的数据页。
使用双写机制，保证数据落盘过程万无一失。防止再写的过程中断电，造成数据丢失。

# 七、MYSQl性能优化篇

1.  首先需要使用慢查询日志，去获取查询时间比较长的SQL语句
2.  查看执行计划，查看有问题的SQL执行计划
3.  针对查询慢的SQL语句进行优化
4.  使用SHOW profile 查看有问题的SQL性能使用情况
5.  调整操作系参数优化
6.  升级服务器硬件

需要手动开启慢查询日志，需要设置阈值。

#临时开启慢查询日志命令
set global slow\_query\_log=ON
set global long\_query\_time=1
#数据库重启失效，长期开启需要去配置文件启动

#### 分析慢查询日志的工具

explain命令 查看执行计划

#### 查看执行执行

使用explain命令 可以对SQL语句的执行计划进行分析

id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.
select_type: SELECT 查询的类型.
table: 查询的是哪个表
partitions: 匹配的分区
type: join 类型 查询类型
possible_keys: 此次查询中可能选用的索引
key: 此次查询中确切使用到的索引.
ref: 哪个字段或常数与 key 一起被使用
rows: 显示此查询一共扫描了多少行. 这个是一个估计值.
filtered: 表示此查询条件所过滤的数据的百分比
extra: 额外的信息

#### SQL语句的优化

##### 1、索引的优化

为搜索字段、排序字段、select查询列建立合适的索引。
尽量建立组合索引，并注意顺序
尽量使用覆盖索引
索引长度尽可能短，短索引可以节省空间
索引的更新不能频繁，更新频繁的数据不适合建索引

##### 2、limit优化

如果预计查询结果只有一个，建议使用limit 1 可以停止全表扫描
处理分页会使用到limit当翻页到后面的时候偏移量会非常大， limit offset size
limit优化问题，其实是offset的问题，他会导致mysql扫描大量不需要的行再抛弃掉。
3、其他查询优化
小表驱动大表，建议使用left join时，以小表关联大表，
避免全表扫描
where 条件中尽量使用 Not in 语句建议使用 not exists
合理利用慢查询日志，explain执行查询计划，show profile查看sql执行时的资源使用情况

4、服务器端优化
缓冲区优化，设置足够大的innodb\_buffer\_pool_size 将数据读取到内存中，
降低磁盘写入次数，对于生产环境来说，部分日志是可以不用的，
mysql数据库配置优化 设置缓冲池内存大小
日志落盘配置

5、操作系统优化
内核参数优化

6、服务器硬件优化
提升硬件设备，例如选择尽量高频率的内存（频率不能高于主板的支持）、提升网络带宽、使用SSD高
速磁盘、提升CPU性能等。

# 七、MySQL集群篇

## 主从复制

2、binlog和relay日志
bin log 记录了所有数据的更改，用于本机数据恢复和主从同步
relayz log ：中继日志

1.  mysql主节点将binlog写入本地，从节点定时请求增量binlog，主节点将binlog同步到从节点
2.  从节点单独进程会将binlog拷贝至本地relaylog中
3.  从节点定时重放relay log。

binlog的日志模式：
1.statement level模式（日志有小概率无法同步的）
2.rowlevel模式(比较耗存储性能)
3.mixed模式（实际上就是前两种模式的结合，在mixed模式下）
在配置文件中开启开启binlog

```
#binlog刷盘策略
sync_binlog=1

0 ：存储引擎不进行binlog的刷新到磁盘，而由操作系统的文件系统控制缓存刷新。
1：每提交一次事务，存储引擎调用文件系统的sync操作进行一次缓存的刷新，这种方式最安全，但性
能较低。
n：当提交的日志组=n时，存储引擎调用文件系统的sync操作进行一次缓存的刷新。


#需要备份的数据库
binlog-do-db=hello
#不需要备份的数据库
binlog-ignore-db=mysql
#启动二进制文件
log-bin=mysql-bin
#服务器ID
server-id=132
```

调整binlog日志模式
binlog的三种格式： STATEMENT 、 ROW 、 MIXED 。

查看bin log和relay log日志
因为binlog日志文件：mysql-bin.000005是二进制文件，没法用vi等打开，这时就需要mysql的自带的
mysqlbinlog工具进行解码，执行： mysqlbinlog mysql-bin.000005 可以将二进制文件转为可阅读的
sql语句。

3、基于binlog主从复制
关闭主从机器的防火墙

主从复制存在一定延迟问题，并且只保证主机对外提供服务，只是在后台为主机进行备份。
配置流程
主服务器配置：

1.  先做数据同步将主服务器的数据全量复制到从服务器
2.  主服务器上配置开启binlog
3.  在主服务器上对复制数据的用户做授权操作
4.  使用show master status语句查看主服务器状态
    从服务器配置：
5.  配置从服务器的server-id参数，在My.cnf文件中配置
6.  如果从服务器使用的是虚拟机，并且是通过克隆得到的虚拟机，需要删除auto.cnf文件，重启服务器，会重新生成此文件
7.  重启mysql服务
8.  change master to命令

## 读写分离

学习书籍：

《从根上理解mysql》

《小林Coding》